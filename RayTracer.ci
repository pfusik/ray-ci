class Vec
{
	double X;
	double Y;
	double Z;
	internal static Vec# Create(double x, double y, double z)
	{
		Vec# result = new Vec();
		result.X = x;
		result.Y = y;
		result.Z = z;
		return result;
	}
	internal Vec# Add(Vec other) => Create(X + other.X, Y + other.Y, Z + other.Z);
	internal Vec# Sub(Vec other) => Create(X - other.X, Y - other.Y, Z - other.Z);
	internal Vec# Scale(double f) => Create(f * X, f * Y, f * Z);
	internal double Dot(Vec other) => X * other.X + Y * other.Y + Z * other.Z;
	internal Vec# Unitise() => Scale(1 / Math.Sqrt(Dot(this)));
}

class Hit
{
	internal double First;
	internal Vec# Second;
}

class Ray
{
	internal Vec# Orig;
	internal Vec# Dir;
}

abstract class Scene
{
	internal abstract Hit# Intersect(Hit# hit, Ray ray);
}

class Sphere : Scene
{
	internal Vec# Center;
	internal double Radius;

	internal static Sphere# Create(Vec# c, double r)
	{
		Sphere# result = new Sphere();
		result.Center = c;
		result.Radius = r;
		return result;
	}

	internal double RaySphere(Ray ray)
	{
		Vec# v = Center.Sub(ray.Orig);
		double b = v.Dot(ray.Dir);
		double disc = b * b - v.Dot(v) + Radius * Radius;
		if (disc < 0)
			return Math.PositiveInfinity;
		double d = Math.Sqrt(disc);
		double t2 = b + d;
		if (t2 < 0)
			return Math.PositiveInfinity;
		double t1 = b - d;
		return t1 > 0 ? t1 : t2;
	}

	internal override Hit# Intersect(Hit# hit, Ray ray)
	{
		double lambda = RaySphere(ray);
		if (lambda >= hit.First)
			return hit;
		hit = new Hit();
		hit.First = lambda;
		hit.Second = ray.Orig.Add(ray.Dir.Scale(lambda)).Sub(Center).Unitise();
		return hit;
	}
}

class Group : Scene
{
	internal Sphere# Bound;
	internal List<Scene#>() Children;

	internal override Hit# Intersect(Hit# hit, Ray ray)
	{
		double l = Bound.RaySphere(ray);
		if (l >= hit.First)
			return hit;
		foreach (Scene# it in Children)
			hit = it.Intersect(hit, ray);
		return hit;
	}
}

public static class RayTracer
{
	const int N = 512;
	const string PgmHeader = $"P5\n{N} {N}\n255\n";
	public const int PgmLength = PgmHeader.Length + N * N;

	static Hit# Intersect(Ray ray, Scene s)
	{
		Hit# hit = new Hit();
		hit.First = Math.PositiveInfinity;
		hit.Second = Vec.Create(0, 0, 0);
		return s.Intersect(hit, ray);
	}

	static double RayTrace(Vec light, Ray ray, Scene s)
	{
		Hit# hit = Intersect(ray, s);
		if (hit.First == Math.PositiveInfinity)
			return 0;
		double g = hit.Second.Dot(light);
		if (g >= 0)
			return 0;
		const double delta = 1.49012e-08;
		Ray() ray2;
		ray2.Orig = ray.Orig.Add(ray.Dir.Scale(hit.First)).Add(hit.Second.Scale(delta));
		ray2.Dir = light.Scale(-1);
		return Intersect(ray2, s).First < Math.PositiveInfinity ? 0 : -g;
	}

	static Scene# Create(int level, Vec# c, double r)
	{
		Scene# s = Sphere.Create(c, r);
		if (level == 1)
			return s;
		Group# group = new Group();
		group.Bound = Sphere.Create(c, 3 * r);
		group.Children.Add(s);
		double rn = 3 * r / Math.Sqrt(12);
		for (int dz = -1; dz <= 1; dz += 2)
			for (int dx = -1; dx <= 1; dx += 2)
				group.Children.Add(Create(level - 1, c.Add(Vec.Create(dx, 1, dz).Scale(rn)), r / 2));
		return group;
	}

	public static void Render(byte[]! pgm, int level = 6)
	{
		const int ss = 4;
		Vec# light = Vec.Create(-1, -3, 2).Unitise();
		Scene# s = Create(level, Vec.Create(0, -1, 0), 1);
		Ray() ray;
		ray.Orig = Vec.Create(0, 0, -4);
		int pgmOffset = 0;
		for (; pgmOffset < PgmHeader.Length; pgmOffset++)
			pgm[pgmOffset] = PgmHeader[pgmOffset];
		for (int y = N; --y >= 0; ) {
			for (int x = 0; x < N; x++) {
				double g = 0;
				for (int dx = 0; dx < ss; dx++) {
					for (int dy = 0; dy < ss; dy++) {
						ray.Dir = Vec.Create(x + dx * 1. / ss - N / 2, y + dy * 1. / ss - N / 2, N).Unitise();
						g += RayTrace(light, ray, s);
					}
				}
				pgm[pgmOffset++] = Math.Truncate(0.5 + 255 * g / (ss * ss));
			}
		}
	}
}
